/**
Format data for use in layer 3 circuit.

This script takes
1. Path to merkle root file (generated by the merkle_tree.rs script): `bigint`
2. layer 2 proofs (after sanitization with sanitize_groth16_proof.py): `Groth16ProofAsInput`
3. blinding factor for the final Pedersen commitment of asset balance sum
and converts it to the format required by the layer 3 circuit: `LayerThreeInputFileShape`

Usage:
```bash
npx ts-node ./scripts/input_prep_for_layer_three.ts \
               --merkle-root-path <path_to_merkle_root_json> \
               --layer-two-sanitized-proof-paths <list_of_paths_to_sanitize_proof_files> \
               --write-layer-three-data-to <path_to_output_json> \
               --blinding-factor <num>
```

Note: the layer two proof paths must be separated by a comma (e.g. "path1,path2,path3")

Example:
```bash
npx ts-node ./scripts/input_prep_for_layer_three.ts \
               --merkle-root-path ./build/merkle_root.json \
               --layer-two-sanitized-proof-paths "./build/layer_two/batch_0/sanitized_proof.json,./build/layer_two/batch_1/sanitized_proof.json" \
               --write-layer-three-data-to ./build/layer_three \
               --blinding-factor 78534060564309
```
**/

import { jsonReviver } from "./lib/json_serde";
import { Groth16ProofAsInput } from "./lib/interfaces";
import { generator_g_formatted, generator_h_formatted, formatScalarPower } from "./lib/pedersen_commitment";

const fs = require('fs');

interface LayerThreeInputFileShape {
    // We need the groth16 proof data for all the layer 2 circuits.
    // It looks like Groth16ProofAsInput, but each field has 1 extra array dimension
    // to account for the fact that there may be more than 1 proof to verify.
    gamma2: number[][][][],
    delta2: number[][][][],
    negalfa1xbeta2: number[][][][],
    IC: number[][][][],
    negpa: number[][][][],
    pb: number[][][][],
    pc: number[][][],

    // Public inputs for the layer 2s.
    // Note that the merkleRoot is not an array, because the values are the same for all layer 2s.
    balances: bigint[],
    merkle_root: bigint,

    // Pedersen commitment values.
    ped_com_generator_g: bigint[][],
    ped_com_generator_h: bigint[][],
    ped_com_blinding_factor: bigint[],
}

function constructInput(proofData: Groth16ProofAsInput[], balances: bigint[], merkleRoot: bigint, blindingFactor: bigint): LayerThreeInputFileShape {
    let layerThreeInput: LayerThreeInputFileShape = {
        gamma2: [],
        delta2: [],
        negalfa1xbeta2: [],
        IC: [],
        negpa: [],
        pb: [],
        pc: [],
        balances,
        merkle_root: merkleRoot,
        ped_com_generator_g: generator_g_formatted,
        ped_com_generator_h: generator_h_formatted,
        ped_com_blinding_factor: formatScalarPower(blindingFactor),
    };

    for (let i = 0; i < proofData.length; i++) {
        layerThreeInput.gamma2.push(proofData[i].gamma2);
        layerThreeInput.delta2.push(proofData[i].delta2);
        layerThreeInput.negalfa1xbeta2.push(proofData[i].negalfa1xbeta2);
        layerThreeInput.IC.push(proofData[i].IC);
        layerThreeInput.negpa.push(proofData[i].negpa);
        layerThreeInput.pb.push(proofData[i].pb);
        layerThreeInput.pc.push(proofData[i].pc);
    }

    return layerThreeInput;
}

var argv = require('minimist')(process.argv.slice(2), {
    alias: {
        merkleRootPath: ['merkle-root-path', 'm'],
        layerTwoSanitizedProofPaths: ['layer-two-sanitized-proof-paths', 'p'],
        layerThreeInputPath: ['write-layer-three-data-to', 'o'],
        blindingFactor: ['blinding-factor', 'b'],
    },
});

let merkleRootPath = argv.merkleRootPath;
let layerTwoSanitizedProofPaths = argv.layerTwoSanitizedProofPaths;
let layerThreeInputPath = argv.layerThreeInputPath;
let blindingFactor: bigint = BigInt(argv.blindingFactor);

let merkleRootRaw = fs.readFileSync(merkleRootPath);
let merkleRoot: bigint = JSON.parse(merkleRootRaw, jsonReviver);

let proofDataArray: Groth16ProofAsInput[] = [];
let balances: bigint[] = [];


for (const layerTwoProofPath of layerTwoSanitizedProofPaths.split(',')) {
    if (!fs.lstatSync(layerTwoProofPath).isFile()) {
        throw new Error(`Expected ${layerTwoProofPath} to be a path to a file`);
    }

    if (layerTwoProofPath.split('.').pop() !== "json") {
        throw new Error(`Expected ${layerTwoProofPath} to be a path to a json file`);
    }

    let proofDataRaw = fs.readFileSync(layerTwoProofPath);
    let proofData: Groth16ProofAsInput = JSON.parse(proofDataRaw, jsonReviver);

    balances.push(proofData.pubInput[0]);
    proofDataArray.push(proofData);
}

let layerThreeInput: LayerThreeInputFileShape = constructInput(proofDataArray, balances, merkleRoot, blindingFactor);

const jsonOut = JSON.stringify(
    layerThreeInput,
    (_, value) => typeof value === "bigint" ? value.toString() : value,
    2
);

fs.writeFileSync(layerThreeInputPath, jsonOut);
